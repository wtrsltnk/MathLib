// Vector.cpp: implementation of the Vector class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Vector::Vector()
{
	this->X = 0.0f;
	this->Y = 0.0f;
	this->Z = 0.0f;
}

Vector::Vector(float X, float Y, float Z)
{
	this->X = X;
	this->Y = Y;
	this->Z = Z;
}

Vector::~Vector()
{
}

////////////////////////////////////////////////////////////////////////////////
/// Purpose : 
/// Input   : 
/// Output  : 
////////////////////////////////////////////////////////////////////////////////
void Vector::Fill(float X, float Y, float Z)
{
	this->X = X;
	this->Y = Y;
	this->Z = Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::Vectorize(Vector V)
{
	return Vector(X - V.X, Y - V.Y, Z - V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::Normalize()
{
	float magnitude = Magnitude();

	*this = *this / magnitude;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
float Vector::Magnitude()
{
	return (float)sqrt( (X * X) + 
						(Y * Y) + 
						(Z * Z) );
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator*=(Vector V)
{
	this->X *= V.X;
	this->Y *= V.Y;
	this->Z *= V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator*(Vector V)
{
	return Vector(X * V.X, Y * V.Y, Z * V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator*(float F)
{
	return Vector(X * F, Y * F, Z * F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator/=(Vector V)
{
	if( V.X == 0 || V.Y == 0 || V.Z == 0 )
		return;
	this->X /= V.X;
	this->Y /= V.Y;
	this->Z /= V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator/(Vector V)
{
	if( V.X == 0 || V.Y == 0 || V.Z == 0 )
		return Vector(0.0f, 0.0f, 0.0f);
	return Vector(X / V.X, Y / V.Y, Z / V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator/(float F)
{
	if ( F == 0 )
		return Vector(X, Y, Z);
	return Vector(X / F, Y / F, Z / F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator+=(Vector V)
{
	this->X += V.X;
	this->Y += V.Y;
	this->Z += V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator+(Vector V)
{
	return Vector(X + V.X, Y + V.Y, Z + V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator+(float F)
{
	return Vector(X + F, Y + F, Z + F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator-=(Vector V)
{
	this->X -= V.X;
	this->Y -= V.Y;
	this->Z -= V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator-(Vector V)
{
	return Vector(X - V.X, Y - V.Y, Z - V.Z);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
Vector Vector::operator-(float F)
{
	return Vector(X - F, Y - F, Z - F);
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
void Vector::operator=(Vector V)
{
	this->X = V.X;
	this->Y = V.Y;
	this->Z = V.Z;
}

////////////////////////////////////////////////////////////////////////////////////
// Purpose : 
// Input   : 
// Output  : 
////////////////////////////////////////////////////////////////////////////////////
bool Vector::Equals(Vector V)
{
	if ( V.X == X && V.Y == Y && V.Z == Z )
		return true;
	return false;
}
